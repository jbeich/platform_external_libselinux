{
  "comments": [
    {
      "key": {
        "uuid": "f80a0e5c_92601a05",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 7,
      "author": {
        "id": 1013433
      },
      "writtenOn": "2015-07-13T16:27:40Z",
      "side": 1,
      "message": "spelling willfix",
      "revId": "bf2e750ab3c8b73f182eba32b8255b26f5812dfc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1821a2e2_4889df73",
        "filename": "src/android.c",
        "patchSetId": 3
      },
      "lineNbr": 1293,
      "author": {
        "id": 1010111
      },
      "writtenOn": "2015-07-13T14:54:11Z",
      "side": 1,
      "message": "This could yield a change in behavior.\nCurrently, we are using this to decide whether to check for a partial match and prune the tree walk early if there is no possible match for anything under a given directory as an optimization during the restorecon_recursive(\"/sys\").  So, for example, if there are no /sys/kernel/debug entries in file_contexts, then it will skip over the children of /sys/kernel/debug entirely.  As long as we only call it with restorecon_recursive(\"/sys\"), this won\u0027t affect anything as the statfs is done on the top level directory.  But if someone did a restorecon -R /sys/kernel/debug before and after this change, the old logic would have skipped its children while the new logic would walk the entire tree.",
      "revId": "bf2e750ab3c8b73f182eba32b8255b26f5812dfc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3801063e_9492ca5c",
        "filename": "src/android.c",
        "patchSetId": 3
      },
      "lineNbr": 1293,
      "author": {
        "id": 1013433
      },
      "writtenOn": "2015-07-13T16:27:40Z",
      "side": 1,
      "message": "by entire tree you mean the /sys/kernel/debug and children ? Why isn\u0027t that an optimization applied to all restorecon_recursive calls? Why only abort early on sysfs paths?",
      "parentUuid": "1821a2e2_4889df73",
      "revId": "bf2e750ab3c8b73f182eba32b8255b26f5812dfc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "78e45ef7_fe107d05",
        "filename": "src/android.c",
        "patchSetId": 3
      },
      "lineNbr": 1293,
      "author": {
        "id": 1010111
      },
      "writtenOn": "2015-07-13T18:52:24Z",
      "side": 1,
      "message": "It only makes sense when dealing with a pseudo filesystem.  For conventional filesystems like ext4 on /data, we will always have a regex that will match all files (/data(/.*)?) to ensure complete labeling.  Whereas with the pseudo filesystem files, they will have some kind of label even if we haven\u0027t touched them via restorecon; we only need to restorecon them if they need a more specific label than the filesystem default.  So I guess it ought to be ispseudofs or something rather than issys, except that we only do a restorecon_recursive of /sys today and many pseudo filesystems don\u0027t even support setxattr.",
      "parentUuid": "3801063e_9492ca5c",
      "revId": "bf2e750ab3c8b73f182eba32b8255b26f5812dfc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f80a0e5c_d2b2a2cf",
        "filename": "src/android.c",
        "patchSetId": 3
      },
      "lineNbr": 1293,
      "author": {
        "id": 1013433
      },
      "writtenOn": "2015-07-13T19:00:43Z",
      "side": 1,
      "message": "That makes a lot more sense. Its really psuedo filesystems pulling a default from genfscon statements. Is their a generic way (without reading the mount table) do determine if the filesystem supports seclabels. Looking through kernfs it looks like setxattr doesn\u0027t always mean support for setxattr and seclabel.",
      "parentUuid": "78e45ef7_fe107d05",
      "revId": "bf2e750ab3c8b73f182eba32b8255b26f5812dfc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1821a2e2_2e53d3e8",
        "filename": "src/android.c",
        "patchSetId": 3
      },
      "lineNbr": 1293,
      "author": {
        "id": 1010111
      },
      "writtenOn": "2015-07-13T19:03:51Z",
      "side": 1,
      "message": "seclabel option in /proc/mounts is the only reliable way to know if the filesystem supports setting SELinux labels.",
      "parentUuid": "f80a0e5c_d2b2a2cf",
      "revId": "bf2e750ab3c8b73f182eba32b8255b26f5812dfc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "389d8670_11b44c22",
        "filename": "src/android.c",
        "patchSetId": 3
      },
      "lineNbr": 1293,
      "author": {
        "id": 1013433
      },
      "writtenOn": "2015-07-13T19:27:11Z",
      "side": 1,
      "message": "ughh parsing, thats no fun. In reality we could change the varname of issys and set it if the ftype is for SYFS and DEBUGFS which seem to be the only 2 that pull a legit starting label from genfscon.\n\nRight now other filesystems are getting skipped if their mounted under sys that shouldn\u0027t be. For instance, you may wish to handle one of the tmpfs\u0027s.",
      "parentUuid": "1821a2e2_2e53d3e8",
      "revId": "bf2e750ab3c8b73f182eba32b8255b26f5812dfc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}