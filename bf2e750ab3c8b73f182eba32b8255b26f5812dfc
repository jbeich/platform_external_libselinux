{
  "comments": [
    {
      "key": {
        "uuid": "f80a0e5c_92601a05",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 7,
      "author": {
        "id": 1013433
      },
      "writtenOn": "2015-07-13T16:27:40Z",
      "side": 1,
      "message": "spelling willfix",
      "revId": "bf2e750ab3c8b73f182eba32b8255b26f5812dfc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1821a2e2_4889df73",
        "filename": "src/android.c",
        "patchSetId": 3
      },
      "lineNbr": 1293,
      "author": {
        "id": 1010111
      },
      "writtenOn": "2015-07-13T14:54:11Z",
      "side": 1,
      "message": "This could yield a change in behavior.\nCurrently, we are using this to decide whether to check for a partial match and prune the tree walk early if there is no possible match for anything under a given directory as an optimization during the restorecon_recursive(\"/sys\").  So, for example, if there are no /sys/kernel/debug entries in file_contexts, then it will skip over the children of /sys/kernel/debug entirely.  As long as we only call it with restorecon_recursive(\"/sys\"), this won\u0027t affect anything as the statfs is done on the top level directory.  But if someone did a restorecon -R /sys/kernel/debug before and after this change, the old logic would have skipped its children while the new logic would walk the entire tree.",
      "revId": "bf2e750ab3c8b73f182eba32b8255b26f5812dfc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3801063e_9492ca5c",
        "filename": "src/android.c",
        "patchSetId": 3
      },
      "lineNbr": 1293,
      "author": {
        "id": 1013433
      },
      "writtenOn": "2015-07-13T16:27:40Z",
      "side": 1,
      "message": "by entire tree you mean the /sys/kernel/debug and children ? Why isn\u0027t that an optimization applied to all restorecon_recursive calls? Why only abort early on sysfs paths?",
      "parentUuid": "1821a2e2_4889df73",
      "revId": "bf2e750ab3c8b73f182eba32b8255b26f5812dfc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "78e45ef7_fe107d05",
        "filename": "src/android.c",
        "patchSetId": 3
      },
      "lineNbr": 1293,
      "author": {
        "id": 1010111
      },
      "writtenOn": "2015-07-13T18:52:24Z",
      "side": 1,
      "message": "It only makes sense when dealing with a pseudo filesystem.  For conventional filesystems like ext4 on /data, we will always have a regex that will match all files (/data(/.*)?) to ensure complete labeling.  Whereas with the pseudo filesystem files, they will have some kind of label even if we haven\u0027t touched them via restorecon; we only need to restorecon them if they need a more specific label than the filesystem default.  So I guess it ought to be ispseudofs or something rather than issys, except that we only do a restorecon_recursive of /sys today and many pseudo filesystems don\u0027t even support setxattr.",
      "parentUuid": "3801063e_9492ca5c",
      "revId": "bf2e750ab3c8b73f182eba32b8255b26f5812dfc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f80a0e5c_d2b2a2cf",
        "filename": "src/android.c",
        "patchSetId": 3
      },
      "lineNbr": 1293,
      "author": {
        "id": 1013433
      },
      "writtenOn": "2015-07-13T19:00:43Z",
      "side": 1,
      "message": "That makes a lot more sense. Its really psuedo filesystems pulling a default from genfscon statements. Is their a generic way (without reading the mount table) do determine if the filesystem supports seclabels. Looking through kernfs it looks like setxattr doesn\u0027t always mean support for setxattr and seclabel.",
      "parentUuid": "78e45ef7_fe107d05",
      "revId": "bf2e750ab3c8b73f182eba32b8255b26f5812dfc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1821a2e2_2e53d3e8",
        "filename": "src/android.c",
        "patchSetId": 3
      },
      "lineNbr": 1293,
      "author": {
        "id": 1010111
      },
      "writtenOn": "2015-07-13T19:03:51Z",
      "side": 1,
      "message": "seclabel option in /proc/mounts is the only reliable way to know if the filesystem supports setting SELinux labels.",
      "parentUuid": "f80a0e5c_d2b2a2cf",
      "revId": "bf2e750ab3c8b73f182eba32b8255b26f5812dfc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "389d8670_11b44c22",
        "filename": "src/android.c",
        "patchSetId": 3
      },
      "lineNbr": 1293,
      "author": {
        "id": 1013433
      },
      "writtenOn": "2015-07-13T19:27:11Z",
      "side": 1,
      "message": "ughh parsing, thats no fun. In reality we could change the varname of issys and set it if the ftype is for SYFS and DEBUGFS which seem to be the only 2 that pull a legit starting label from genfscon.\n\nRight now other filesystems are getting skipped if their mounted under sys that shouldn\u0027t be. For instance, you may wish to handle one of the tmpfs\u0027s.",
      "parentUuid": "1821a2e2_2e53d3e8",
      "revId": "bf2e750ab3c8b73f182eba32b8255b26f5812dfc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b8c33659_b5c46085",
        "filename": "src/android.c",
        "patchSetId": 3
      },
      "lineNbr": 1293,
      "author": {
        "id": 1013433
      },
      "writtenOn": "2015-07-13T19:38:18Z",
      "side": 1,
      "message": "wrt things under sysfs. Their\u0027s a bunch more filesystem\u0027s that we likely need to have the proper prune logic on as well. functionfs, pstorefs, usbfs (is that even used anymore).",
      "parentUuid": "389d8670_11b44c22",
      "revId": "bf2e750ab3c8b73f182eba32b8255b26f5812dfc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "786b7e31_bd926f5c",
        "filename": "src/android.c",
        "patchSetId": 3
      },
      "lineNbr": 1293,
      "author": {
        "id": 1010111
      },
      "writtenOn": "2015-07-14T13:32:53Z",
      "side": 1,
      "message": "That\u0027s why I\u0027m thinking the current test of /sys prefix is better/safer for this purpose than switching over to testing filesystem type.",
      "parentUuid": "b8c33659_b5c46085",
      "revId": "bf2e750ab3c8b73f182eba32b8255b26f5812dfc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b871761d_eee193be",
        "filename": "src/android.c",
        "patchSetId": 3
      },
      "lineNbr": 1293,
      "author": {
        "id": 1010111
      },
      "writtenOn": "2015-07-14T13:32:53Z",
      "side": 1,
      "message": "The reason that /proc/mounts seclabel is the only reliable means of testing is because even a filesystem that implements support for labeling might have that support overridden via a context\u003d mount option and therefore might not support setxattr for a particular mount.  I don\u0027t think there is anything under /sys that is of concern; even tmpfs inodes are not persistent and have an initial default label (e.g. tmpfs type) and therefore the logic for pruning the walk is fine for those as well if there is no possible matching entry in file_contexts.  Would only matter if someone started mounting ext4 filesystems under /sys, which would be just weird.",
      "parentUuid": "389d8670_11b44c22",
      "revId": "bf2e750ab3c8b73f182eba32b8255b26f5812dfc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}