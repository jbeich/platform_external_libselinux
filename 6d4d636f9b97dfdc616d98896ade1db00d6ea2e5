{
  "comments": [
    {
      "key": {
        "uuid": "24bf01e0_0bcd4d43",
        "filename": "src/android.c",
        "patchSetId": 7
      },
      "lineNbr": 1433,
      "author": {
        "id": 1003966
      },
      "writtenOn": "2014-06-25T23:07:36Z",
      "side": 1,
      "message": "Maybe better for \"aux\" to be a void*, instead of a char*? That seems to be the format preferred by selinux_check_access.",
      "revId": "6d4d636f9b97dfdc616d98896ade1db00d6ea2e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a4ca118f_2234b062",
        "filename": "src/android.c",
        "patchSetId": 7
      },
      "lineNbr": 1433,
      "author": {
        "id": 1048048
      },
      "writtenOn": "2014-06-25T23:08:34Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "24bf01e0_0bcd4d43",
      "revId": "6d4d636f9b97dfdc616d98896ade1db00d6ea2e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a46cd148_12a1b29c",
        "filename": "src/android.c",
        "patchSetId": 7
      },
      "lineNbr": 1433,
      "author": {
        "id": 1010111
      },
      "writtenOn": "2014-06-26T12:50:11Z",
      "side": 1,
      "message": "Comparing with check_mac_perms() in init/property_service.c, differences are:\n- check_mac_perms() checks is_selinux_enabled() and returns 1/true in that case.\n- check_mac_perms() checks for a NULL scon and handle and treats either one as an error.\n- check_mac_perms() does not call ALOGE() on anything.  I\u0027m wondering how useful the error message below is given that it tells us nothing about the call chain, the class or perm in question, etc.  Should either augment to at least report the class/perm or drop altogether and leave it to the caller.\n\nOne other observation: presently (both in the existing property_service and servicemanager code and here) a non-existent or corrupted *_contexts configuration will lead to denials on all checks even if the device is put into permissive mode due to the error handling path on !sehandle or selabel_lookup() failure.  One possible alternative would be to check security_getenforce() in the error path and only fail the permission check if 1, otherwise just log an error but proceed.",
      "parentUuid": "a4ca118f_2234b062",
      "revId": "6d4d636f9b97dfdc616d98896ade1db00d6ea2e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8497cd5d_cb6abdfe",
        "filename": "src/android.c",
        "patchSetId": 7
      },
      "lineNbr": 1433,
      "author": {
        "id": 1010111
      },
      "writtenOn": "2014-06-26T14:02:21Z",
      "side": 1,
      "message": "BTW, rather than calling is_selinux_enabled() on each call, we can just follow the example in src/checkAccess.c and call it once and save the result in a static, as it will not change.  Or maybe this test is completely irrelevant now in Android since SELinux is required.",
      "parentUuid": "a46cd148_12a1b29c",
      "revId": "6d4d636f9b97dfdc616d98896ade1db00d6ea2e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}