{
  "comments": [
    {
      "key": {
        "uuid": "b81fb653_237f898c",
        "filename": "src/android.c",
        "patchSetId": 1
      },
      "lineNbr": 1292,
      "author": {
        "id": 1010111
      },
      "writtenOn": "2015-07-09T13:52:29Z",
      "side": 1,
      "message": "There is also a debugfs mount on /sys/kernel/debug and a pstore mount on /sys/fs/pstore.\nI would tend to parenthesize the boolean expression above even though it isn\u0027t technically required.",
      "revId": "b93d4d40c817685695c961d09d1f8519c958318f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "58e87a65_4bb2ad56",
        "filename": "src/android.c",
        "patchSetId": 1
      },
      "lineNbr": 1292,
      "author": {
        "id": 1010111
      },
      "writtenOn": "2015-07-09T14:10:18Z",
      "side": 1,
      "message": "And the list of filesystems under /sys seems to keep growing, e.g. on modern Linux, you have multiple cgroup mounts, configfs, securityfs as well.  Maybe the test for the /sys prefix is simpler in the end...",
      "parentUuid": "b81fb653_237f898c",
      "revId": "b93d4d40c817685695c961d09d1f8519c958318f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d3260d9c_0c383bda",
        "filename": "src/android.c",
        "patchSetId": 1
      },
      "lineNbr": 1292,
      "author": {
        "id": 1013433
      },
      "writtenOn": "2015-07-09T16:22:33Z",
      "side": 1,
      "message": "Sure, but their are conditions where it behaves incorrectly as well. However this model would handle multiple mounts of types scattered without having to deal with paths, so as with anything no free lunch.",
      "parentUuid": "58e87a65_4bb2ad56",
      "revId": "b93d4d40c817685695c961d09d1f8519c958318f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d8246aa6_d36d4bfb",
        "filename": "src/android.c",
        "patchSetId": 1
      },
      "lineNbr": 1292,
      "author": {
        "id": 1010111
      },
      "writtenOn": "2015-07-09T16:36:53Z",
      "side": 1,
      "message": "True.  Pity we don\u0027t have something analogous to seclabel mount option output in /proc/self/mounts, which can be used to detect which filesystems support security labeling.  But here we want to know which filesystems support persistent labeling, not just labeling in general.",
      "parentUuid": "d3260d9c_0c383bda",
      "revId": "b93d4d40c817685695c961d09d1f8519c958318f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b3219987_74289612",
        "filename": "src/android.c",
        "patchSetId": 1
      },
      "lineNbr": 1292,
      "author": {
        "id": 1013433
      },
      "writtenOn": "2015-07-09T16:50:45Z",
      "side": 1,
      "message": "I was thinking that the logic would be simpler if flipped. We should say don\u0027t do setlast unless its an fs type that we want to persist and then do the path based exclusion. AFAIK and have seen, that limits us to the EXT family and if we want to hop in the way back machine, yaffs.",
      "parentUuid": "d8246aa6_d36d4bfb",
      "revId": "b93d4d40c817685695c961d09d1f8519c958318f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "58115a41_fa701e53",
        "filename": "src/android.c",
        "patchSetId": 1
      },
      "lineNbr": 1292,
      "author": {
        "id": 1010111
      },
      "writtenOn": "2015-07-09T17:00:50Z",
      "side": 1,
      "message": "And f2fs, although last I looked, they still didn\u0027t have support in system/extras/f2fs_utils for labeling files, so I don\u0027t quite understand how they can use f2fs currently with SELinux unless they do a post-install restorecon or something.\nOTOH, using a whitelist of f_type values here would mean that we will have to update it whenever a new fs type is introduced for userdata.  With the current blacklist of f_type values the worst that will happen is that it will try to set restorecon_last and fail, but that is not fatal.",
      "parentUuid": "b3219987_74289612",
      "revId": "b93d4d40c817685695c961d09d1f8519c958318f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "78ca9e3a_8b13ed10",
        "filename": "src/android.c",
        "patchSetId": 1
      },
      "lineNbr": 1292,
      "author": {
        "id": 1013433
      },
      "writtenOn": "2015-07-10T20:02:51Z",
      "side": 1,
      "message": "CGROUP is covered by TMPFS\n# /data/statfs /sys/fs/cgroup/memory                                \nf_type: 1021994\n\nWe need DEBUGFS_MAGIC for debugfs. What\u0027s strange is that their is a restorecon_recursive on sys, and I never saw the trigger on setattr for last for that filesystem.",
      "parentUuid": "58115a41_fa701e53",
      "revId": "b93d4d40c817685695c961d09d1f8519c958318f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}